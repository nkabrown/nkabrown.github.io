<!DOCTYPE html><html lang="en"><head>
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width">
      <title>Nathan K A Brown</title>
      <link rel="stylesheet" href="../e0d2b393.css">
      <link rel="stylesheet" href="../6fdf2784.css">
      <link rel="preconnect" href="https://fonts.googleapis.com">
      <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
      <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@300;400;600;700&amp;display=swap" rel="stylesheet">
    
</head>
    <body>
      <main><!--lit-part BRUAAAUVAAA=--><!--lit-part 0RY5kp63bvc=--><!-- prettier-ignore --><!--/lit-part--><!--lit-part 2CsNmn6XysQ=--><h2 id="setting-a-browser-support-baseline"><a aria-hidden="true" tabindex="-1" href="#setting-a-browser-support-baseline"><span class="icon icon-link"></span></a>Setting a Browser Support Baseline</h2>
<ul>
<li><a href="https://github.com/browserslist/browserslist">browserslist</a> - targeted browser list for tooling</li>
<li><a href="https://github.com/amilajack/eslint-plugin-compat">eslint-plugin-compat</a> - linting for browser compatible code patterns</li>
</ul>
<p>Only support relatively modern browsers. The simplest way to test user agent support is through the <code>@support</code> CSS conditional rule and I'm checking for CSS feature support in <code>outdated-browser-wall.css</code>. Supporting relatively modern browsers enables usage of new JS, CSS, and Web API features without the need to polyfill. Users on outdated browsers are gently reminded to update or switch improving the future for both users and developers.</p>
<p>Using the browser support baseline I've set in <code>outdated-browser-wall.css</code> with <a href="https://github.com/browserslist/browserslist">browserslist</a> I can improve the targeting accuracy of some specific frontend tools. The browser support baseline is replicated in my <code>.browserslistrc</code> file.</p>
<h2 id="pre-commit-hook"><a aria-hidden="true" tabindex="-1" href="#pre-commit-hook"><span class="icon icon-link"></span></a>Pre-commit Hook</h2>
<ul>
<li><a href="https://github.com/typicode/husky">husky</a> - easily setup git hooks</li>
<li><a href="https://github.com/okonet/lint-staged">lint-staged</a> - execute scripts on staged files via git pre-commit hook</li>
</ul>
<p>One of the most valuable processes to improve the quality of code reviews is to setup a pre-commit hook that lints and formats all code going to a PR. Linting helps catch common errors and suggests best practices. It's an automated code review. Enforcing formatting removes whole classes of nit-picky issues around layout, such as indentation variance and semi-colon usage. This pre-commit hook can be bypassed with <code>git commit --no-verify</code>, but codebases should be kept clean of linting errors and effort should be expended to remove linting errors and warnings.</p>
<p>I'm using <a href="https://typicode.github.io/husky/#/">husky</a> to easily create git hooks. It's important to add <code>husky install</code> to your <code>prepare</code> script in <code>package.json</code> so git hooks are installed when new team members run <code>npm install</code> or <code>npm ci</code>. I'm using <a href="https://github.com/okonet/lint-staged">lint-staged</a> to run the formatter and linter as shell scripts on staged files. These tasks run concurrently by default but can be configured to run in order to avoid race conditions, see <a href="https://github.com/okonet/lint-staged#task-concurrency">task concurrency</a>.</p>
<p>You can encourage the use of the pre-commit hook by instructing developers to use <code>npm ci</code> instead of <code>npm install</code> in your READMEs. The <code>npm ci</code> command will setup available git hooks as well as install exact versions of dependencies promoting consistency across environments and between team members.</p>
<h2 id="code-formatting"><a aria-hidden="true" tabindex="-1" href="#code-formatting"><span class="icon icon-link"></span></a>Code Formatting</h2>
<ul>
<li><a href="https://prettier.io/">prettier</a> - low configuration opinionated code formatter</li>
<li><a href="https://github.com/prettier/eslint-config-prettier">eslint-config-prettier</a> - turn off linting rules that conflict with prettier</li>
</ul>
<p>I am using <a href="https://prettier.io">prettier</a> to format this project code, particularly when files are staged to be commited. Prettier is a low configuration tool which strictly limits what can be configured. In this sense it's opinionated and makes many code formatting decisions for you. I use a simple configuration file with minimal exceptions to prettier's defaults, such as, avoiding parentheses in arrow functions, using single quotes in JavaScript and TypeScript files, and setting a 4 space indentation level on markdown files.</p>
<p>Formatting code is an important step to complete before code review to eliminate whole classes of nit-picky issues. Reviewers can focus on more substantive issues. Rework is minimized.</p>
<p>The formatter can be run manually over all files with <code>npx prettier --write .</code> or via <code>npm run format</code> or over any subset of files with <code>npx prettier --write "src/**/*.css"</code> as one example.</p>
<p>When manually formatting files it's polite to keep formatting changes in a separate commit from other code changes. This makes formatting changes easy to isolate during code reviews.</p>
<h2 id="linting"><a aria-hidden="true" tabindex="-1" href="#linting"><span class="icon icon-link"></span></a>Linting</h2>
<ul>
<li><a href="https://eslint.org">ESLint</a> - static analysis to find and fix JavaScript problems</li>
<li><a href="https://github.com/prettier/eslint-config-prettier">eslint-config-prettier</a> - turn off linting rules that conflict with prettier</li>
<li><a href="https://github.com/amilajack/eslint-plugin-compat">eslint-plugin-compat</a> - linting for browser compatible code patterns</li>
<li><a href="https://github.com/BenoitZugmeyer/eslint-plugin-html">eslint-plugin-html</a> - apply linting rules to inline scripts in html</li>
<li><a href="https://github.com/43081j/eslint-plugin-lit">eslint-plugin-lit</a> - linting rules for Lit templating library</li>
<li><a href="https://open-wc.org/docs/linting/eslint-plugin-lit-a11y/overview/">eslint-plugin-lit-a11y</a> - linting rules for accessibility in lit components</li>
<li><a href="https://github.com/43081j/eslint-plugin-wc">eslint-plugin-wc</a> - linting rules for custom elements (web components)</li>
</ul>
<p>I am using <a href="https://eslint.org">ESLint</a> to lint project frontend code, particularly files that are staged to be committed. ESLint statically analyzes JavaScript code looking for code patterns that may cause errors, fall short of best practices, or cause code formatting issues. Each file of code is parsed into an abstract syntax tree (AST). The linter walks down the AST and then back up visiting each node twice. Each node's type triggers related linting rules and the linter collects and reports observed errors and warnings.</p>
<p>I use rules from the <code>eslint:recommend</code> configuration file to report common problems. I'm using <code>eslint-config-prettier</code> to turn off the layout linting rules related to code formatting since <code>prettier</code> handles those issues. I have web component/Lit specific rules from the <code>wc</code> and <code>lit</code> plugins and extend their recommended rules with a few additions. The <code>lit-a11y</code> plugin spots accessibility issues within web components/Lit. I'm using <code>eslint-plugin-compat</code> to provide IDE support and linting against my browser support baseline. My JS linting rules are applied to inline scripts in HTML by the <code>html</code> plugin.</p>
<h2 id="housekeeping-for-lintingformatting-tasks"><a aria-hidden="true" tabindex="-1" href="#housekeeping-for-lintingformatting-tasks"><span class="icon icon-link"></span></a>Housekeeping for Linting/Formatting Tasks</h2>
<p>In POSIX a process exit status other than zero is interpreted as failure of the process to accomplish its task and an error is thrown. ESLint and Prettier will end their process with exit status <code>1</code> if a linting error or unformatted file is found. This is very helpful when incorporating linting or formatting into a CI pipeline. It's not helpful when running these processes as part of development where the goal is clean reporting of linting errors and formatting omissions. I add <code>exit 0</code> to the end of my non-CI linting/formatting scripts to report successful accomplishment of the linting/formatting task and avoid throwing errors in the terminal.</p>
<h2 id="why-do-i-prefer-yaml-for-my-configuration-files"><a aria-hidden="true" tabindex="-1" href="#why-do-i-prefer-yaml-for-my-configuration-files"><span class="icon icon-link"></span></a>Why do I prefer YAML for my configuration files?</h2>
<p>Both JSON and YAML are data serialization languages, but YAML supports comments. YAML is also becoming the preferred configuration language for infrastructure, being perceived as more human readable and simpler than JSON. I've chosen to configure my tooling with YAML wherever possible to align myself with current trends in configuration and to build familiarity with this configuration language.</p>
<p><strong>Resources to learn YAML</strong></p>
<ul>
<li><a href="https://learnxinyminutes.com/docs/yaml/">Learn YAML in Y minutes</a></li>
<li><a href="https://www.yaml.info/learn/index.html">Learn YAML</a></li>
</ul>
<h2 id="upgrading-scripts"><a aria-hidden="true" tabindex="-1" href="#upgrading-scripts"><span class="icon icon-link"></span></a>Upgrading Scripts</h2>
<ul>
<li><a href="https://github.com/google/wireit">Wireit</a></li>
</ul>
<p>I use the Wireit library to optimize <code>npm</code> script processes and re-run scripts when dependencies change. Wireit allows incremental updating of scripts with minimal changes to <code>package.json</code>, linking scripts together as dependencies, speedups to builds and testing through caching and incremental builds, and triggering scripts based on changes to watched files.</p>
<h2 id="bundling"><a aria-hidden="true" tabindex="-1" href="#bundling"><span class="icon icon-link"></span></a>Bundling</h2>
<ul>
<li><a href="https://rollupjs.org/">rollup</a> - tree-shaking ES6 module bundler for JavaScript</li>
<li><a href="https://github.com/vladshcherbin/rollup-plugin-copy">rollup-plugin-copy</a> - copy files and directories</li>
<li><a href="https://github.com/jleeson/rollup-plugin-html-literals">rollup-plugin-html-literals</a> - minify html and css template literals</li>
<li><a href="https://github.com/rollup/plugins/tree/master/packages/node-resolve">@rollup/plugin-node-resolve</a> - resolve paths to node modules</li>
<li><a href="https://github.com/rollup/plugins/tree/master/packages/replace">@rollup/plugin-replace</a> - replace targeted strings</li>
<li><a href="https://yousifalraheem.github.io/rollup-plugin-summary/">rollup-plugin-summary</a> - summarizes size of rollup build output</li>
<li><a href="https://github.com/rollup/plugins/tree/master/packages/terser">@rollup/plugin-terser</a> - parse, mangle, and minify JS with terser</li>
</ul>
<p>I want to combine my individual files and components into an application in an optimized way and I use Rollup as my module bundler to accomplish this. Rollup makes bundles leaner and improves application start-up time. Rollup uses the EcmaScript module standard instead of non-standardized module approaches like CommonJS and AMD. Rollup also statically analyzes code imports and performs <a href="https://rollupjs.org/faqs/#what-is-tree-shaking">tree-shaking</a> to remove unused code from the bundle output.</p>
<p>This selection of plugins is compatible with Rollup v3. For guidance on migrating from Rollup v2 to v3 see the <a href="https://rollupjs.org/migration/">Rollup v3 migration guide</a>.</p>
<h2 id="repository-healthcheck"><a aria-hidden="true" tabindex="-1" href="#repository-healthcheck"><span class="icon icon-link"></span></a>Repository Healthcheck</h2>
<ul>
<li>Is there a pre-commit hook that lints and formats code prior to PRs?</li>
<li>Are the project dependencies out-of-date?</li>
<li>Is the README effective for new joiners?</li>
</ul>
<h3 id="regular-dependency-updates"><a aria-hidden="true" tabindex="-1" href="#regular-dependency-updates"><span class="icon icon-link"></span></a>Regular Dependency Updates</h3>
<p>Regular dependency updates are important for long-lasting codebases. For short-term projects and one-off scripts nothing might ever have to change, but for software that is in use for a long enough period of time everything will likely have to change, eventually. Regular dependency updates are a good practice because they chunk the amount of changes we have to review and navigate into a managable amount and save us from problematic version migrations. They keep our systems in tip-top shape and help us avoid technical debt.</p>
<p>Make them regular because:</p>
<ul>
<li>You want to keep the number of changes you have to review for any dependency at any one time minimal.</li>
<li>You want to avoid deferring breaking changes and gathering them all up into a problematic, complex, and hard to understand series of version migrations.</li>
<li>You want to resolve security vulernabilites promptly.</li>
<li>You want new improvements and fixes to flow into your project regularly.</li>
<li>You want your technical debt to be minimal and managable.</li>
</ul>
<p>You want to do this knowledgably and with care. This is not an automated, thoughtless process. You want to review the change log of every dependency as you update. For prod dependencies in particular you will want to glance at the open issues that have recently come in to avoid problematic versions.</p>
<p>Here's a short example guide to the process for frontend teams that can be added to a README or CONTRIBUTING page.</p>
<p><strong>Updating Dependencies</strong></p>
<p>Regularly updating dependencies and dev dependencies is very beneficial for long lasting codebases.</p>
<ul>
<li>Run <code>npm outdated</code> to list dependencies in need of review.</li>
<li>Review release notes and/or change logs for list of dependencies with new updates.
<ul>
<li>Is there new functionality this codebase can use?</li>
<li>Do changes need to be made to upgrade?</li>
<li>Are any problematic issues associated with these changes?</li>
</ul>
</li>
<li>Run <code>npx browserslist-lint</code> to update <code>caniuse-lite</code> database.</li>
</ul>
<h3 id="ensuring-your-readme-works"><a aria-hidden="true" tabindex="-1" href="#ensuring-your-readme-works"><span class="icon icon-link"></span></a>Ensuring Your README Works</h3>
<p>Many READMEs miss the mark for the types of readers who are most likely to read them: new joiners and maintainers returning after a long absence. READMEs should have all the information these readers need to independently and quickly get setup and contributing.</p>
<p>Your README needs to have a detailed and up-to-date list of support tickets that need to be raised for a new joiner, local development instructions, and important contextual knowledge like links to dependency documentation. And this information should be ordered so that these important readers can easily find it.</p>
<p>Take time to evaluate and improve your READMEs.</p>
<ul>
<li>Does your README support onboarding new team members?</li>
<li>Is your README all someone needs to have to get up and running?</li>
<li>Is your README up-to-date?</li>
<li>Is the most relevant information easy to find?</li>
</ul><!--/lit-part--><!----><!--/lit-part--></main>
    
  


</body></html>